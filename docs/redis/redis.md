# Redis

Remote Dictionary Server (Redis) 는 키와 값 구조로 형성된 데이터를 관리해주는 시스템이다. 인-메모리 구조를 가지고 있어서 데이터베이스 외에도 캐싱 또는 메시지 브로커로도 사용된다.

레디스는 다음과 같은 자료구조 형식을 제공해준다.

- Strings
- Hash
- List
- Set
- Sorted Set
- Bitmaps
- Hyperloglogs
- Geospatial Indexes
- Streams

레디스는 데이터들을 메모리에 쓰고 읽기 때문에 일반 데이터베이스보다 빠른 속도를 보장한다. 그러나 단점은 서버가 죽거나 기계가 꺼지면 메모리에 있는 내용들은 전부 다 삭제된다. 그러므로 레디스를 사용할때는 데이터 유실을 방지하는 방법에 대해서도 고민하면서 개발 작업을 해야 한다. 그럼 어떻게 데이터를 안전하고 효율적으로 보관할 수 있을까?

### 데이터 관리

레디스는 2가지 방법으로 데이터를 보관한다.

- **RDB (Redis Database)**

    - RDB, 즉 snapshot 방식은 특정 시간때 데이터셋을 디스크에 바이너리 파일로 저장하는 방법이다.
    
    - 장점:
        - 백업으로 유용하다. 예를 분기별로 또는 매월 저장할 수 있겠금 특정 시간을 정해 전체 데이터들을 저장할 수 있으므로 서버에 장애가 발생해도 원하는 시간때의 파일을 복구할 수 있다.

        - 전체 데이터셋이 단일 파일로 구성되기 때문에 다른 서버/기계로 이동이 편하다.

        - 데이터 양이 커지면 AOF보다 빠르게 불러올 수 있다.
        
    - 단점:
        - RDB 는 특정 시간때 데이터들을 저장하는 방식으로 그 사이 서버가 다운되면 데이터 일부가 유실된다.

        - RDB 는 자식프로세스를 fork() 해서 작압을 처리하기 때문에 데이터 양이 커지면 메로리 용량과 CPU 상황에 따라 수행시간이 늘어날 수 있다.

- **AOF (Append Only File)**

    - AOF 는 모든 쓰기 작업을 로그에다 쌓아놓는 방법으로 서버가 다시 시작할 때 원본 데이터를 다시 작성한다.

    - 장점:
        - AOF 는 append-only 방식으로 파일을 잃지 않고 빠른 속도로 추가하기 때문에 파일 손상을 막을 수 있다. 중간에 로그를 작성하다가 서버가 다운되어도 redis-check-aof-tool 기능이 이 문제를 쉽게 해결해준다.

        - 레디스는 데이터 양이 커지면 작업이 수행되는 중에도 자동으로 새로운 파일을 만들어 준다.

        - 사용자가 실수도 전체 데이터를 삭제했어도 데이터 복구가 가능하다. 서버를 멈추고 로그 파일에 들어가 마지막 작업을 삭제하고 서버를 다시 시작하면 된다.

    - 단점:
        - 동일한 데이터셋을 가지고 있어도 파일 크기가 RDB 에 비해 크다.

        - 희귀한 버그들이 발생한다...

Redis 공식 문서에는 2가지 방법을 같이 사용하는 것을 권장한다. 

### 레디스 관리

**데이터를 효율적**으로 관리하는 부분에 있어서 위에 2가지 방법을 사용하지만 **데이터를 안전**하게 관리하기 위해서는 레디스 서버를 복제해야 한다. 레디스도 [Kafka](../kafka/kafka_part1.md) 처럼 서버들을 복제해서 장애를 대비한다. 여기서 Master/Leader 서버는 모든 쓰기 작업을 처리를 하고 Slave/Follower 서버들에 복사한다. 만약 복제한 서버 연결이 끊기고 재접속 되어도 마스터 서버와 똑같은 복제본을 갖을 수 있다.

레디스는 3 가지 흐름으로 복제본을 만든다.

1. 마스터와 복제용 서버들의 연결이 좋으면 복제 서버는 마스터에게 꾸준히 명령을 받아 업데이트 한다.

2. 만약 마스터와 복제본의 끊기면 마스터는 버퍼에 작업을 담아둔다. 그 후 복제본과 재접속되면 복제본은 버퍼의 작업을 받아 연결이 끊긴 지점부터 부분 동기화를 거쳐 작업을 업데이트 한다.

3. 부분 동기화가 불가능하면 전체 동기화를 요청한다. 전체 동기화를 하면 미스터 서버는 snapshot 을 만든 후 복제본을 만든다. 동시에 마스터에 들어오는 작업들은 버퍼에 담아둔다. Snapshot 을 완성되면 복제본에게 전송하고 복제본은 읽어서 메모리에 적재시킨다. 그 후 마스터에 버퍼에 담은 작업들을 전송한다.

이렇게 복제본을 만들면 읽기 작업을 여러 서버로 분산시켜 부하를 줄일 수 있다.

### Redis Sentinel

레디스 Sentinel 은 레디스 오류에 대해서 사람의 개입없이 레디스를 관리해주는 역할을 한다.

Sentinel 역할:

- Master 와 replica 들이 잘 작동하는지 모니터링한다.
- 문제가 발생하면 관리자에게 알림을 준다.
- Master 에 문제가 생기면 replica 에 master 권한을 부여하고 나머지 설정을 관리해준다.
- Redis 에 대한 정보와 설정들을 사용자에게 제공해준다.

Sentinel 은 모든 레디스 서버와 Sentinel 들과 연결을 한 후 heartbeat 를 통해 마스터와 복제본 상태를 확인한다.

Sentinel 3 번이 마스터에 장애가 있는걸 감지하면 나머지 Sentinel 을 통해 마스터가 확실히 장애가 발생했는지 확인한다. [Kafka](../kafka/kafka_part1.md) 에서도 그렇듯이 쿼럼 (quorum) 을 통해 장애 여부를 판단한다. 만약 장애가 있다고 판단하면 복제본에 마스터를 이관하고 나머지 바뀐 설정을 나머지 서버들에 적용시켜 준다.

### 메모리 관리

레디스는 인-메모리 구조를 가지고 있어서 메모리 관리도 중요하다. 그럼 레디스는 메모리 관리를 어떻게 할까? 레디스는 메모리의 한계를 `maxmemory` 를 통해 설정할 수 있다. 만약 설정한 `maxmemory` 값에 도달하면 레디스는 `maxmemory-policy` 를 통해 메모리 관리를 한다.

- **noeviction** : 에러를 반환한다.

- **allkeys-lru** : Less Recently Used (LRU) 페이지 교체 알고리즘을 통해 얻은 키들을 제거한다.

- **volatile-lru** : lru를 통해 키들을 구하지만 지정된 시간 후 자동 삭제 되는 집합 (expire set) 에 속한 키들을 제거한다.

- **allkeys-random** : 무작위로 키를 골라서 제거한다.

- **volatile-random** : 무작위로 키를 고르지만 expire set 에 포한된 키들을 제거한다.

- **volatile-ttl** : Expire set 에 포함된 키들 중에서 가장 짧은 생명을 가진 (Time To Live) 키들을 먼저 제거한다.


Redis 공식 문서에서는 메모리 확보에 정확한 답이 없으면 `allkeys-lru` 를 권장한다.


<br>

**YouTube -> Redis Labs 에서 참고할 수 있는 동영상이 많다.**

