---
title: "Data Structure & Algorithms"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

이곳은 자료구조와 알고리즘에 대해 직접 학습하고 자료 정리를 위한 문서이다.  

----------------  
### 메모리란? (Memory)  

자료구조를 배우기전에 메모리가 대충 무엇인지 어떤 역할을 하는지 알고있는게 중요하다. 노트북을 살때 메모리가 8GB, 16GB 이라고 들어본적이 있을것이다. 정말 간단히 요약 하자면 메모리는 마치 휴게소 역할을 하는 임시 저장소라고 생각하면 편할꺼 같다. 반대로 HDD 또는 SSD 저장 장치는 영구적이며 읽고/쓰기 속도는 메모리보다 느리다. 그래서 앱을 실행시킬 때 우리가 바로 읽고 사용할 수 있게 데이터들은 메모리에 저장이 된다. 단점은 컴퓨터를 끄면 메모리에 저장된 데이터들을 다 지워진다. 

왜 메모리에 대한 개념이 중요하나? 예를 들어 변수를 지정할때 아니면 결과를 반환할때 그 결과값은 메모리 안 어딘가에는 할당이 될 것이다. **이것을 어떻게 효율적으로 할당해서 불러오고 사용할 수 있는지를 배우는게 자료구조이다.**



### 배열 (Array)  

배열은 한가지의 데이터 타입으로 묶여진 집합이다. 배열을 생성할 때 크기를 정한다. 예를 들면`int L[5];`는 크기가 5인 배열이다. 메모리에서 정수의 크기는 4 byte이다. 그러므로 `L` 배열은 20 byte 크기의 메모리가 할당이 된다. 배열에서는 주어진 크기 안에서는 데이터를 삽입하거나 제거할 수 있으나 배열의 사이즈는 못 바꾼다. 예를 들면 뒤에 데이터를 덧붙이지 못한다. 그리고 메모리에 임의로 할당 되어서 배열값을 할당한 후 다른 변수가 그 뒤에 할당될 수도 있다. 그러므로 배열의 크기를 조정하려면 다른 메모리 주소에 할당을 해야된다. 이때 이전에 있던 배열의 데이터를 그대로 불러온 후 그 뒤에 추가로 데이터들을 삽입하면 된다. 이때 주로 배열의 크기를 전 배열의 2배를 할당한다. 그러나 할당된 메모리를 모두 사용하지 않으면 자원을 버리는 것이므로 단점이 있으나 또 한편으로는 데이터를 읽는 속도는 일정한 장점이 있다.


### 연결 리스트 (Linked List)  

배열의 크기를 너무 크게 지정하면 메모리 자원을 낭비하게 된다. 연결 리스트는 이 문제를 해결해준다. 배열은 크기가 정해져 있어서 n 번째 값은 배열이 시작하는 메모리 주소에 찾고자 하는 값의 인덱스 값에 4를 곱하면 n번째 값을 찾을 수 있다. 그러나 연결 리스트는 각 값들이 메모리에 임의로 할당이 되어 있어 추가적인 정보가 필요하다. 그래서 연결 리스트는 각 값마다 8 bytes의 메모리가 할당된다. 4 bytes는 값에 해당되고 나머지 4 bytes는 다음 값이 있는 메모리 주소에 해당된다. 이것을 '노드 (Node)' 라고 한다. 비록 배열에 비해 메모리를 더 사용하지만 배열처럼 값을 추가하려면 다른 곳으로 모두 이동해야하는 번거러움이 없어서 값을 추가하고 제거하기 편하다. 하지만 배열은 특정 값을 찾을때 시간이 일정하지만 연결 리스트는 각 노드를 거쳐야 하기 때문에 배열보다는 속도가 느린 단점이 있다.


### 이중 연결 리스트 (Doubly Linked List)

단일 연결 리스트는 다음 노드의 주소가 저장되어 있다. 그래서 노드를 한 방향으로만 이동할 수 있다. 만약 반대로 이동하려면 반복문 또는 재귀 함수를 사용해야 하며 많은 변수를 사용해서 정보를 지정해야 한다. 그러나 이중 연결 리스트는 하나의 노드 안에 다음 노드 주소와 이전 주소가 포함되어 있어 데이터를 앞뒤로 쉽게 읽을 수 있다. 하지만 하나의 단점은 노드에 3가지의 정보가 들어 있어서 (데이터를 정수라고 가정하면) 총 12 bytes 의 메모리를 차지한다. 



