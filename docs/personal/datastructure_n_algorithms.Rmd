---
title: "Data Structure & Algorithms"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

이곳은 자료구조와 알고리즘에 대해 직접 학습하고 자료 정리를 위한 문서이다.  

----------------  
### 메모리란? (Memory)  

자료구조를 배우기전에 메모리가 대충 무엇인지 어떤 역할을 하는지 알고있는게 중요하다. 노트북을 살때 메모리가 8GB, 16GB 이라고 들어본적이 있을것이다. 정말 간단히 요약 하자면 메모리는 마치 휴게소 역할을 하는 임시 저장소라고 생각하면 편할꺼 같다. 반대로 HDD 또는 SSD 저장 장치는 영구적이며 읽고/쓰기 속도는 메모리보다 느리다. 그래서 앱을 실행시킬 때 우리가 바로 읽고 사용할 수 있게 데이터들은 메모리에 저장이 된다. 단점은 컴퓨터를 끄면 메모리에 저장된 데이터들을 다 지워진다. 

왜 메모리에 대한 개념이 중요하나? 예를 들어 변수를 지정할때 아니면 결과를 반환할때 그 결과값은 메모리 안 어딘가에는 할당이 될 것이다. **이것을 어떻게 효율적으로 할당해서 불러오고 사용할 수 있는지를 배우는게 자료구조이다.**



### 배열 (Array)  

배열은 한가지의 데이터 타입으로 묶여진 집합이다. 배열을 생성할 때 크기를 정한다. 예를 들면`int L[5];`는 크기가 5인 배열이다. 메모리에서 정수의 크기는 4 byte이다. 그러므로 `L` 배열은 20 byte 크기의 메모리가 할당이 된다. 배열에서는 주어진 크기 안에서는 데이터를 삽입하거나 제거할 수 있으나 배열의 사이즈는 못 바꾼다. 예를 들면 뒤에 데이터를 덧붙이지 못한다. 그리고 메모리에 임의로 할당 되어서 배열값을 할당한 후 다른 변수가 그 뒤에 할당될 수도 있다. 그러므로 배열의 크기를 조정하려면 다른 메모리 주소에 할당을 해야된다. 이때 이전에 있던 배열의 데이터를 그대로 불러온 후 그 뒤에 추가로 데이터들을 삽입하면 된다. 이때 주로 배열의 크기를 전 배열의 2배를 할당한다. 그러나 할당된 메모리를 모두 사용하지 않으면 자원을 버리는 것이므로 단점이 있으나 또 한편으로는 데이터를 읽는 속도는 일정한 장점이 있다.


### 연결 리스트 (Linked List)  

배열의 크기를 너무 크게 지정하면 메모리 자원을 낭비하게 된다. 연결 리스트는 이 문제를 해결해준다. 배열은 크기가 정해져 있어서 n 번째 값은 배열이 시작하는 메모리 주소에 찾고자 하는 값의 인덱스 값에 4를 곱하면 n번째 값을 찾을 수 있다. 그러나 연결 리스트는 각 값들이 메모리에 임의로 할당이 되어 있어 추가적인 정보가 필요하다. 그래서 연결 리스트는 각 값마다 8 bytes의 메모리가 할당된다. 4 bytes는 값에 해당되고 나머지 4 bytes는 다음 값이 있는 메모리 주소에 해당된다. 이것을 '노드 (Node)' 라고 한다. 비록 배열에 비해 메모리를 더 사용하지만 배열처럼 값을 추가하려면 다른 곳으로 모두 이동해야하는 번거러움이 없어서 값을 추가하고 제거하기 편하다. 하지만 배열은 특정 값을 찾을때 시간이 일정하지만 연결 리스트는 각 노드를 거쳐야 하기 때문에 배열보다는 속도가 느린 단점이 있다.


### 이중 연결 리스트 (Doubly Linked List)

단일 연결 리스트는 다음 노드의 주소가 저장되어 있다. 그래서 노드를 한 방향으로만 이동할 수 있다. 만약 반대로 이동하려면 반복문 또는 재귀 함수를 사용해야 하며 많은 변수를 사용해서 정보를 지정해야 한다. 그러나 이중 연결 리스트는 하나의 노드 안에 다음 노드 주소와 이전 주소가 포함되어 있어 데이터를 앞뒤로 쉽게 읽을 수 있다. 하지만 하나의 단점은 노드에 3가지의 정보가 들어 있어서 (데이터를 정수라고 가정하면) 총 12 bytes 의 메모리를 차지한다. 

### 스택 (Stack)

스택은 접근 제한이 있는 리스트이다. 스택에서는 데이터가 한 곳 (주로 탑 (top) 이라고도 한다) 에서만 삽입되고 제거할 수 있다. 쉽게 말하면 데이터의 입구와 출구가 한 군데에서 이루어진다. 그래서 `Last In First Out`, 마직막으로 들어온게 먼저 나간다라는 개념을 가지고 있다. 스택에는 몇 가지 작업들이 있다. `push(x)` 는 데이터를 삽입할 때 사용하고 `pop()` 은 데이터를 제거할 때 사용한다. 그 외에도 `Top()`은 마지막으로 들어온 데이터 값을 확인할 수 있고 `IsEmpty()`는 스택에 값이 있는지 없는지 확인할 수 있다. 이러한 작업들을 수행하는데 일정한 시간이 걸린다.  

배열에서는 스택을 사용해 데이터를 삽입/제거 하면 일정 시간이 걸린다. 마지막에 들어온 데이터에 추가하거나 제거하면 된다. 그러나 초반에 배열의 크기를 적게 정해서 overflow (할당된 메모리보다 더 사용하는) 현상이 일어나면 배열의 크기를 늘려야 (주로 2배로) 한다. 그러면 전 배열을 복사한 후 데이터를 추가할 수 있으므로 처리 시간이 길어진다. 그러므로 배열을 사용할 때는처음에 적당한 크기를 정하는게 중요하다.  

연결 리스트에서 스택을 사용하려면 두가지 방법이 있다. 마지막 노드에 추가하거나 제거하는 방법과 첫 노드 앞에 추가 또는 제거하는 방법이다. 그러나 마지막 노드에 추가/제거하면 `n`번 노드를 이동해야 하기 때문에 수행작업이 일정하지 않다. 반대로 헤드 노드 앞에 추가/제거하면 스택의 작업들을 항상 일정한 시간이 걸리므로 스택을 사용하려면 헤드 노드에 시행해야 한다.  


### 큐 (Queue)  

스택은 `Last In First Out`이라는 개념을 같고 있다. 반대로 큐는 `First In First Out` 개념을 가지고 있으므로 먼저 들어온 데이터를 먼저 처리할 수 있는 구조이다. 큐에도 스택처럼 몇 가지 작업들이 있다. 예를 들면 `Enqueue()`는 데이터를 넣으는 함수, `Dequeue()`는 데이터를 추출하는 함수이며 이러한 작업들은 처리하는데 일정한 시간이 걸린다.  

프린터기를 생각해보자. 5개의 문서를 출력하려는 요청이 들어오면 프린터기는 동시에 5개의 문서를 출력을 못한다. 그래서 먼저 출력 요청이 들어온 문서를 처리하고 그 다음 문서를 출력하도록 설계가 되어있다. 이 외에도 작업 스케줄링 등 요청을 처리하는 곳에 많이 사용된다.  

예를 들어 크기가 10인 배열이 있고 데이터는 오른쪽에서 들어오고 왼쪽에서 나간다고 하자. 데이터가 3개가 들어오면 1개의 데이터가 제거 된다하면 10번쨰 위치에 데이터가 추가될 때 왼쪽에 3개가 (인덱스 0, 1, 2) 비워져 있을 것이다. 만약 모든 배열을 채우려 하면은 원형 큐 (원형 배열) 개념을 사용하면 된다. 배열이 인덱스 9에 갔을때 다음 인덱스를 0으로 가게 알고리즘을 짜면 된다. 예를 들어 `i` 를 현재 인덱스 위치라 하고 `N`을 배여의 크기라 하면, 다음 위치를 `(i + 1) % N`으로 하면 원형 배열을 만들 수 있다.

배열에 데이터가 다 채워지면 두가지 방법이 있다. 더이상 데이터를 못 들어오게 하거나 아니면 배열 사이즈를 늘리는 거다. 그러나 이것은 이전 배열을 복붙해야 해서 시간이 걸리고 비효율적이다. 연결 리스트에서 큐를 사용하려면 먼저 연결 리스트를 생성할때 헤드의 포인터와 마지막 테일의 포인터를 만들어 정보를 저장한다. 만약 테일 (마지막) 노드에 데이터를 추가하려면 테일의 포인터를 사용해 데이터를 추가하면 된다. 반대로 데이터를 제거하려면 헤드의 포인터를 사용하고 포인터를 바꾸면 된다. 원래 연결 리스트는 크기에 따라 처리 시간이 다르지만 위에와 같은 방식으로 접근하면 일정한 시간으로 데이터를 처리할 수 있다.

