---
title: "Data Structure & Algorithms"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

이곳은 자료구조와 알고리즘에 대해 직접 학습하고 자료 정리를 위한 문서이다.  

----------------  
### 메모리란? (Memory)  

자료구조를 배우기전에 메모리가 대충 무엇인지 어떤 역할을 하는지 알고있는게 중요하다. 노트북을 살때 메모리가 8GB, 16GB 이라고 들어본적이 있을것이다. 정말 간단히 요약 하자면 메모리는 마치 휴게소 역할을 하는 임시 저장소라고 생각하면 편할꺼 같다. 반대로 HDD 또는 SSD 저장 장치는 영구적이며 읽고/쓰기 속도는 메모리보다 느리다. 그래서 앱을 실행시킬 때 우리가 바로 읽고 사용할 수 있게 데이터들은 메모리에 저장이 된다. 단점은 컴퓨터를 끄면 메모리에 저장된 데이터들을 다 지워진다. 

왜 메모리에 대한 개념이 중요하나? 예를 들어 변수를 지정할때 아니면 결과를 반환할때 그 결과값은 메모리 안 어딘가에는 할당이 될 것이다. **이것을 어떻게 효율적으로 할당해서 불러오고 사용할 수 있는지를 배우는게 자료구조이다.**



### 배열 (Array)  

배열은 한가지의 데이터 타입으로 묶여진 집합이다. 배열을 생성할 때 크기를 정한다. 예를 들면`int L[5];`는 크기가 5인 배열이다. 메모리에서 정수의 크기는 4 byte이다. 그러므로 `L` 배열은 20 byte 크기의 메모리가 할당이 된다. 배열에서는 주어진 크기 안에서는 데이터를 삽입하거나 제거할 수 있으나 배열의 사이즈는 못 바꾼다. 예를 들면 뒤에 데이터를 덧붙이지 못한다. 그리고 메모리에 임의로 할당 되어서 배열값을 할당한 후 다른 변수가 그 뒤에 할당될 수도 있다. 그러므로 배열의 크기를 조정하려면 다른 메모리 주소에 할당을 해야된다. 이때 이전에 있던 배열의 데이터를 그대로 불러온 후 그 뒤에 추가로 데이터들을 삽입하면 된다. 이때 주로 배열의 크기를 전 배열의 2배를 할당한다. 그러나 할당된 메모리를 모두 사용하지 않으면 자원을 버리는 것이므로 단점이 있으나 또 한편으로는 데이터를 읽는 속도는 일정한 장점이 있다.


### 연결 리스트 (Linked List)  

배열의 크기를 너무 크게 지정하면 메모리 자원을 낭비하게 된다. 연결 리스트는 이 문제를 해결해준다. 배열은 크기가 정해져 있어서 n 번째 값은 배열이 시작하는 메모리 주소에 찾고자 하는 값의 인덱스 값에 4를 곱하면 n번째 값을 찾을 수 있다. 그러나 연결 리스트는 각 값들이 메모리에 임의로 할당이 되어 있어 추가적인 정보가 필요하다. 그래서 연결 리스트는 각 값마다 8 bytes의 메모리가 할당된다. 4 bytes는 값에 해당되고 나머지 4 bytes는 다음 값이 있는 메모리 주소에 해당된다. 이것을 '노드 (Node)' 라고 한다. 비록 배열에 비해 메모리를 더 사용하지만 배열처럼 값을 추가하려면 다른 곳으로 모두 이동해야하는 번거러움이 없어서 값을 추가하고 제거하기 편하다. 하지만 배열은 특정 값을 찾을때 시간이 일정하지만 연결 리스트는 각 노드를 거쳐야 하기 때문에 배열보다는 속도가 느린 단점이 있다.


### 이중 연결 리스트 (Doubly Linked List)

단일 연결 리스트는 다음 노드의 주소가 저장되어 있다. 그래서 노드를 한 방향으로만 이동할 수 있다. 만약 반대로 이동하려면 반복문 또는 재귀 함수를 사용해야 하며 많은 변수를 사용해서 정보를 지정해야 한다. 그러나 이중 연결 리스트는 하나의 노드 안에 다음 노드 주소와 이전 주소가 포함되어 있어 데이터를 앞뒤로 쉽게 읽을 수 있다. 하지만 하나의 단점은 노드에 3가지의 정보가 들어 있어서 (데이터를 정수라고 가정하면) 총 12 bytes 의 메모리를 차지한다. 

### 스택 (Stack)

스택은 접근 제한이 있는 리스트이다. 스택에서는 데이터가 한 곳 (주로 탑 (top) 이라고도 한다) 에서만 삽입되고 제거할 수 있다. 쉽게 말하면 데이터의 입구와 출구가 한 군데에서 이루어진다. 그래서 `Last In First Out`, 마직막으로 들어온게 먼저 나간다라는 개념을 가지고 있다. 스택에는 몇 가지 작업들이 있다. `push(x)` 는 데이터를 삽입할 때 사용하고 `pop()` 은 데이터를 제거할 때 사용한다. 그 외에도 `Top()`은 마지막으로 들어온 데이터 값을 확인할 수 있고 `IsEmpty()`는 스택에 값이 있는지 없는지 확인할 수 있다. 이러한 작업들을 수행하는데 일정한 시간이 걸린다.  

배열에서는 스택을 사용해 데이터를 삽입/제거 하면 일정 시간이 걸린다. 마지막에 들어온 데이터에 추가하거나 제거하면 된다. 그러나 초반에 배열의 크기를 적게 정해서 overflow (할당된 메모리보다 더 사용하는) 현상이 일어나면 배열의 크기를 늘려야 (주로 2배로) 한다. 그러면 전 배열을 복사한 후 데이터를 추가할 수 있으므로 처리 시간이 길어진다. 그러므로 배열을 사용할 때는처음에 적당한 크기를 정하는게 중요하다.  

연결 리스트에서 스택을 사용하려면 두가지 방법이 있다. 마지막 노드에 추가하거나 제거하는 방법과 첫 노드 앞에 추가 또는 제거하는 방법이다. 그러나 마지막 노드에 추가/제거하면 `n`번 노드를 이동해야 하기 때문에 수행작업이 일정하지 않다. 반대로 헤드 노드 앞에 추가/제거하면 스택의 작업들을 항상 일정한 시간이 걸리므로 스택을 사용하려면 헤드 노드에 시행해야 한다.  


### 큐 (Queue)  

스택은 `Last In First Out`이라는 개념을 같고 있다. 반대로 큐는 `First In First Out` 개념을 가지고 있으므로 먼저 들어온 데이터를 먼저 처리할 수 있는 구조이다. 큐에도 스택처럼 몇 가지 작업들이 있다. 예를 들면 `Enqueue()`는 데이터를 넣으는 함수, `Dequeue()`는 데이터를 추출하는 함수이며 이러한 작업들은 처리하는데 일정한 시간이 걸린다.  

프린터기를 생각해보자. 5개의 문서를 출력하려는 요청이 들어오면 프린터기는 동시에 5개의 문서를 출력을 못한다. 그래서 먼저 출력 요청이 들어온 문서를 처리하고 그 다음 문서를 출력하도록 설계가 되어있다. 이 외에도 작업 스케줄링 등 요청을 처리하는 곳에 많이 사용된다.  

예를 들어 크기가 10인 배열이 있고 데이터는 오른쪽에서 들어오고 왼쪽에서 나간다고 하자. 데이터가 3개가 들어오면 1개의 데이터가 제거 된다하면 10번쨰 위치에 데이터가 추가될 때 왼쪽에 3개가 (인덱스 0, 1, 2) 비워져 있을 것이다. 만약 모든 배열을 채우려 하면은 원형 큐 (원형 배열) 개념을 사용하면 된다. 배열이 인덱스 9에 갔을때 다음 인덱스를 0으로 가게 알고리즘을 짜면 된다. 예를 들어 `i` 를 현재 인덱스 위치라 하고 `N`을 배여의 크기라 하면, 다음 위치를 `(i + 1) % N`으로 하면 원형 배열을 만들 수 있다.

배열에 데이터가 다 채워지면 두가지 방법이 있다. 더이상 데이터를 못 들어오게 하거나 아니면 배열 사이즈를 늘리는 거다. 그러나 이것은 이전 배열을 복붙해야 해서 시간이 걸리고 비효율적이다. 연결 리스트에서 큐를 사용하려면 먼저 연결 리스트를 생성할때 헤드의 포인터와 마지막 테일의 포인터를 만들어 정보를 저장한다. 만약 테일 (마지막) 노드에 데이터를 추가하려면 테일의 포인터를 사용해 데이터를 추가하면 된다. 반대로 데이터를 제거하려면 헤드의 포인터를 사용하고 포인터를 바꾸면 된다. 원래 연결 리스트는 크기에 따라 처리 시간이 다르지만 위에와 같은 방식으로 접근하면 일정한 시간으로 데이터를 처리할 수 있다.

### 트리 (Tree)  

지금까지 배운 자료구조는 선형 구조 또는 순차적으로 정리된 구조이다. 트리는 비선형 구조이며 계층 적 구조로 설계된 자료구조이다. 

![](pics/tree_structure.png)  

트리는 노드들로 연결되어 있으며 위에 그림을 보면 F를 트리의 루트 (root) 라고 한다. 그리고 밑을 가리키는 노드들을 자식 (children) 노드라 부른다. 쉽게 생각하려면 가계도를 생각하면 된다. F 노드는 A 와 D 노드(형재 노드)의 조부모이며 B 노드의 부모이다. 그리고 D 와 I 는 사촌이다. 여기서 자식이 없는 노드를 리프 (leaf) 노드라고 부른다. 그 외에도 선조와 자손의 개념이 있다. 예를 들면 C 노드는 D, B, F의 자손이며 A 와 C의 공통 조상은 B와 F이다.  

트리 구조상 노드의 수를 N 개라 가정하면 노드들을 연결하는 선/링크 (links)를 간선 (edges)라 부르며 N-1개 존재한다. 노드의 깊이 (depth)는 루트 노드에서 해당 노드의 간선 갯수이다. 그리고 높이 (height)는 해당 노드에서 리프 노드와의 최대 길이를 가리킨다. 예를 들어 B노드의 깊이는 1이며 높이는 2이다 (B->A = 1, B->D->E = 2).


### 이진 트리 (Binary Tree)  

트리 구조는 많은 부분에서 응용할 수 있다. 예를 들면 파일 시스템, 자료정리, 네트워크 등 빠른 처리가 필요한 부분에 많이 사용된다. 이진 트리는 부모 노드가 최대 2개의 자식 노드를 가질 수 있는 트리 구조이다. 위에 트리 구조 사진을 보면 부모 노드인 F는 2개의 자식 노드를 가지고 있으며 B 노드를 왼쪽 자식, G를 오른쪽 자식이라 한다. 

이진 트리의 종류:

- **엄격한 이진 트리 (strict/proper binary tree)**: 부모 노드는 0개 아니면 2개의 자식 노드만 가진다.
- **완전 이진 트리 (complete binary tree)**: 마지막 층을 제외한 나머지 층에는 각 부모 노드마다 2개의 자식 노드가 있어야 한다. 그리고 만약 마지막 층에 자식 노드가 1개이면 이것은 최대한 왼쪽 자식 노드에 위치해야 한다.
- **완벽 이진 트리 (perfect binary tree)**: 모든 레벨이 채워저 있는 이진 트리이다. 즉 각 부모 노드는 2개의 자식 노드를 가지고 있는 트리이다. 완벽 이진 트리에서는 노드 갯수를 계산하는게 편하다. h를 루트 노드에서 마지막 레벨에 있는 노드의 길이라고 가정하면 노드의 수는 $N = 2^{h+1}-1$ 이다. 여기서 로그를 취해 h값을 찾을 수도 있다.
- **균형 이진 트리(balanced binary tree)**: 각 부모 노드의 왼쪽 자식과 오른쪽 자식의 차이가 $x \le 1$이면 균형이 있는 이진 트리라고 한다.

트리의 높이는 루트 노드에서 리프 노드까지의 링크의 길이다. 아무 노드가 없는 트리의 높이는 -1 이고 1개 노드가 있는 트리의 높이는 0 이다. 왼쪽 자식과 오른쪽 자식의 차이를 $|h_{완쪽} - h_{오른쪽}|$로 표현하면 위에 그림에서 H 노드는 자식이 없으므로 차이는 $|-1 - (-1)| = 0$ 이다. 그리고 G 노드는 오른쪽 자식을 가지고 있으므로 차이는 $|-1 - 1| = 2$ 이므로 균형 이진 트리가 아니란걸 볼 수 있다.

연결 리스트로 이진 트리를 만들 수 있다. 예를 들어 정수 (4 바이트) 데이터를 사용하면 총 12 bytes의 메모리가 필요하다. 첫 4 바이트  왼쪽 자식 포인터 다음 4 바이트는 데이터 그리고 마지막 4 바이트는 오른쪽 자식 포인터를 할당하면 된다. 그리고 배열에도 이진 트리를 사용할 수 있다. 각 레벨마다 왼쪽부터 오른쪽으로 인덱싱을 해주면 된다. 위 그림을 예로 들면 [F, B, G, A, D, ...] 형태로 배열을 만들 수 있다. 그러나 배열 형태로 사용하면 위에 완벽 이진 트리가 아니면 인덱싱 하는게 어려울꺼 같다.  


### 이진 탐색 트리 (Binary Search Tree)  

이진 탐색 트리는 왼쪽 자식 노드는 부모 노드보다 작거나 같은 값을 가지고 오른쪽 자식 노드는 부모 노드의 값보다 큰 값을 가진 형태의 이진 트리이다. 이것은 자료들을 빨리 검색하고 업데이트 할 수 있도록 설계된 효율적인 자료 구조이며 균형 이진 트리 형태를 사용해야 한다. 

![](pics/bst.png)

위에 그림을 보면 루트 노드에 10의 값이 있다. 왼쪽 자식 노드는 $5 \le 10$ 그리고 오른쪽 노드는 $19 > 10$ 이며 밑에 노드들도 이진 탐색 트리 조건을 만족한다. 추가로 루트를 중심으로 왼쪽 부분인 노드들의 모든 값들도 루트 노드의 값보다 작거나 같아야 하고 오른쪽 부분의 모든 값들은 커댜한다. 예를 들어 위에 그림에 6을 가지고 있는 리프 노드 값을 12로 바꾸면 부모 노드인 5에는이진 탐색 트리 조건을 만족 할 수 있어도 루트 노드보다 값이 크므로 이진 탐색 트리가 아니다.

위에 그림을 배열로 나열해서 이진 탐색 트리의 예를 들어보겠다. 원래 배열에서는 특정 값을 찾으려면 인덱스 0부터 마지막 인덱스까지 읽으면서 값을 찾는다. 그러나 이진 탐색 트리는 일반 배열에서 특정 값을 찾는 시간을 $log$ 시간으로 단축할 수 있게 만든다. 위에 있는 값들을 배열로 형태로 보여주면 [1, 5, 6, 10, 17, 19, 21, ...] 이며 6을 찾아 보겠다. 먼저 배열의 중심값을 찾는다 (여기서는 10). 찾으려는 값 6이 중심값보다 작으므로 배열의 마지막 인덱스를 n이 아닌 중심값 이전인 인덱스 2로 바꿔 [1, 5, 6] 값들 중에서 찾는다. 이제 중심값은 5이며 찾으려는 값은 중심값보다 크므로 오른쪽 부분으로 시작 인덱스를 옮겨 [6] 배열을 만든다. 이 배열의 중심값이 6이며 우리가 찾으려는 값과 일치하다. 

예시로 들은 배열은 작으므로 시간이 단축 된다고 안 느껴질 수 있다. 배열의 크기를 $n = 10^8$이라 하고 1개 값을 읽으는데 $10^{-6}$초가 걸린다고 하자. 최악의 경우 마지막 값을 찾으려면 $10^8$ x $10^{-6} = 100$초가 걸린다. 그러나 이진 탐색 트리는 $\log_{2}n$번의 비교가 있다. 배열의 크기를 이전 배열보다 큰 $2^{31}$이라 가정하고 이진 탐색 트리를 사용하면 $31$x$10^{-6}$초가 걸린다. 즉 1초도 안걸린다. 데이터 크기가 커질수록 기존 배열에서 찾는 시간과 이진 탐색 트리를 사용해서 찾는 시간의 크게 차이난다.

